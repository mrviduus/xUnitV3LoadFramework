# Framework Alternatives for xUnitV3LoadFramework

## Overview

This document explores alternative approaches to implementing load testing functionality without requiring a custom test framework, allowing standard xUnit v3 tests (`[Fact]`, `[Theory]`) to work alongside load tests.

## The Problem

The current implementation uses a custom test framework that replaces xUnit v3's default framework:

```csharp
[assembly: TestFramework("xUnitV3LoadFramework.Extensions.Framework.LoadTestFramework", "xUnitV3LoadFramework")]
```

This causes issues:
- Standard `[Fact]` and `[Theory]` tests don't work properly
- Only tests with `[Load]` attribute are discovered
- Conflicts with xUnit v3's built-in test discovery and execution
- xUnit v3 uses different interfaces (prefixed with `_`) and async patterns

## Solution Options for xUnit v3

### Option 1: Remove Test Framework - Use Test Collections with xUnit v3

Remove the framework declaration completely and use xUnit v3's built-in test collection mechanism.

**Remove from GlobalUsings.cs:**
```csharp
// Remove this line:
// [assembly: TestFramework("xUnitV3LoadFramework.Extensions.Framework.LoadTestFramework", "xUnitV3LoadFramework")]
```

**Create a custom test collection for xUnit v3:**
```csharp
using Xunit;
using Xunit.v3;

[CollectionDefinition("Load Tests")]
public class LoadTestCollection : ICollectionFixture<LoadTestFixture>
{
}

public class LoadTestFixture : IAsyncLifetime
{
    private readonly Dictionary<string, LoadTestOrchestrator> _orchestrators = new();

    public async ValueTask InitializeAsync()
    {
        // Initialize load testing infrastructure
        await ValueTask.CompletedTask;
    }

    public async ValueTask DisposeAsync()
    {
        foreach (var orchestrator in _orchestrators.Values)
        {
            await orchestrator.DisposeAsync();
        }
    }

    public async ValueTask RunLoadTest(MethodInfo method, LoadAttribute loadAttribute, object testInstance)
    {
        var key = $"{method.DeclaringType?.FullName}.{method.Name}";
        
        if (!_orchestrators.TryGetValue(key, out var orchestrator))
        {
            orchestrator = new LoadTestOrchestrator(loadAttribute);
            _orchestrators[key] = orchestrator;
        }

        await orchestrator.ExecuteLoadTest(method, testInstance);
    }
}
```

### Option 2: Use BeforeAfterTestAttribute (xUnit v3 Compatible)

Transform the `LoadAttribute` to extend `BeforeAfterTestAttribute`. Note that in xUnit v3, this needs to work with async patterns:

```csharp
using System.Reflection;
using Xunit.v3;
using Xunit.Sdk;

[AttributeUsage(AttributeTargets.Method, AllowMultiple = false)]
public class LoadAttribute : BeforeAfterTestAttribute
{
    private static readonly Dictionary<string, LoadTestOrchestrator> Orchestrators = new();
    private LoadTestOrchestrator? _orchestrator;
    
    public int Order { get; }
    public int Concurrency { get; }
    public int Duration { get; }
    public int Interval { get; }

    public LoadAttribute(int order = 1, int concurrency = 1, int duration = 1000, int interval = 100)
    {
        Order = order;
        Concurrency = concurrency;
        Duration = duration;
        Interval = interval;
    }

    public override async ValueTask Before(MethodInfo methodUnderTest, IXunitTest test)
    {
        var key = $"{methodUnderTest.DeclaringType?.FullName}.{methodUnderTest.Name}";
        
        if (!Orchestrators.TryGetValue(key, out _orchestrator))
        {
            _orchestrator = new LoadTestOrchestrator(this);
            Orchestrators[key] = _orchestrator;
        }
        
        TestContext.Current = new TestContext
        {
            TestName = methodUnderTest.Name,
            StartTime = DateTime.UtcNow,
            TestUniqueId = test.UniqueID
        };
        
        await ValueTask.CompletedTask;
    }

    public override async ValueTask After(MethodInfo methodUnderTest, IXunitTest test)
    {
        // Cleanup if needed
        await ValueTask.CompletedTask;
    }
}
```

### Option 3: Use ITestCaseOrderer (xUnit v3 Version)

Create a test case orderer that handles load tests specially. Note xUnit v3 uses `_ITestCase`:

```csharp
using Xunit.v3;
using Xunit.Sdk;

public class LoadTestCaseOrderer : ITestCaseOrderer
{
    public IEnumerable<TTestCase> OrderTestCases<TTestCase>(IEnumerable<TTestCase> testCases) 
        where TTestCase : _ITestCase
    {
        var regularTests = new List<TTestCase>();
        var loadTests = new List<(TTestCase testCase, LoadAttribute attr)>();

        foreach (var testCase in testCases)
        {
            // In xUnit v3, we need to check the test method differently
            var testMethod = testCase.TestMethod;
            var methodInfo = testMethod?.Method;
            
            if (methodInfo != null)
            {
                var loadAttr = methodInfo.GetCustomAttributes(typeof(LoadAttribute))
                    .FirstOrDefault() as LoadAttribute;

                if (loadAttr != null)
                {
                    loadTests.Add((testCase, loadAttr));
                }
                else
                {
                    regularTests.Add(testCase);
                }
            }
        }

        // Run regular tests first
        foreach (var test in regularTests)
            yield return test;

        // Then run load tests ordered by their Order property
        foreach (var (testCase, _) in loadTests.OrderBy(t => t.attr.Order))
            yield return testCase;
    }
}
```

**Usage:**
```csharp
[TestCaseOrderer("xUnitV3LoadFramework.Extensions.LoadTestCaseOrderer", "xUnitV3LoadFramework")]
public class MyTests
{
    [Fact]
    public void RegularTest() { }
    
    [Fact]
    [Load(concurrency: 10, duration: 5000)]
    public async Task LoadTest() { }
}
```

### Option 4: Simple Helper Method Pattern for xUnit v3 (Recommended)

The simplest approach - use regular xUnit v3 tests and call a helper method:

```csharp
using System;
using System.Threading;
using System.Threading.Tasks;
using Xunit.v3;

namespace xUnitV3LoadFramework.Extensions;

public static class LoadTestRunner
{
    public static async ValueTask RunLoadTest(
        Func<Task> testAction,
        int concurrency = 1,
        int duration = 1000,
        int interval = 100,
        CancellationToken cancellationToken = default)
    {
        var orchestrator = new LoadTestOrchestrator(concurrency, duration, interval);
        await orchestrator.RunAsync(testAction, cancellationToken);
    }
    
    public static async ValueTask RunLoadTest(
        Func<ValueTask> testAction,
        int concurrency = 1,
        int duration = 1000,
        int interval = 100,
        CancellationToken cancellationToken = default)
    {
        var orchestrator = new LoadTestOrchestrator(concurrency, duration, interval);
        await orchestrator.RunAsync(() => testAction().AsTask(), cancellationToken);
    }
}
```

**Usage in tests with xUnit v3:**
```csharp
using Xunit;
using xUnitV3LoadFramework.Extensions;

public class WebTests : IAsyncLifetime
{
    private HttpClient? _httpClient;
    private TestSetup? _setup;

    public async ValueTask InitializeAsync()
    {
        _setup = new TestSetup();
        await _setup.InitializeAsync();
        _httpClient = _setup.Host.Services.GetRequiredService<IHttpClientFactory>().CreateClient();
    }

    public async ValueTask DisposeAsync()
    {
        _httpClient?.Dispose();
        if (_setup != null)
            await _setup.DisposeAsync();
    }

    [Fact]
    public async Task TestGoogleIsWorking_LoadTest()
    {
        await LoadTestRunner.RunLoadTest(
            async () =>
            {
                var response = await _httpClient!.GetAsync("https://www.google.com");
                Assert.True(response.IsSuccessStatusCode);
            },
            concurrency: 2,
            duration: 5000,
            interval: 500
        );
    }

    [Fact]
    public async Task TestGoogleIsWorking_SingleRequest()
    {
        // Regular test - runs once
        var response = await _httpClient!.GetAsync("https://www.google.com");
        Assert.True(response.IsSuccessStatusCode);
    }
}
```

### Option 5: xUnit v3 Custom Test Attribute (New Alternative)

Create a custom test attribute that works with xUnit v3's execution model:

```csharp
using System;
using System.Threading.Tasks;
using Xunit.v3;
using Xunit.Sdk;

[XunitTestCaseDiscoverer("xUnitV3LoadFramework.LoadFactDiscoverer", "xUnitV3LoadFramework")]
[AttributeUsage(AttributeTargets.Method, AllowMultiple = false)]
public class LoadFactAttribute : FactAttribute
{
    public int Order { get; set; } = 1;
    public int Concurrency { get; set; } = 1;
    public int Duration { get; set; } = 1000;
    public int Interval { get; set; } = 100;
}

public class LoadFactDiscoverer : FactDiscoverer
{
    protected override ValueTask<IReadOnlyCollection<IXunitTestCase>> CreateTestCasesForFact(
        _ITestFrameworkDiscoveryOptions discoveryOptions,
        _ITestMethod testMethod,
        _IAttributeInfo factAttribute)
    {
        var loadAttr = factAttribute as LoadFactAttribute;
        if (loadAttr != null)
        {
            var testCase = new LoadFactTestCase(
                testMethod,
                loadAttr.Order,
                loadAttr.Concurrency,
                loadAttr.Duration,
                loadAttr.Interval);
            
            return new ValueTask<IReadOnlyCollection<IXunitTestCase>>(new[] { testCase });
        }
        
        return base.CreateTestCasesForFact(discoveryOptions, testMethod, factAttribute);
    }
}
```

## xUnit v3 Specific Considerations

1. **Async Patterns**: xUnit v3 uses `ValueTask` instead of `Task` for async operations
2. **Interface Naming**: v3 interfaces are prefixed with underscore (e.g., `_ITestCase`, `_IMessageSink`)
3. **IAsyncLifetime**: Use `ValueTask` in `InitializeAsync` and `DisposeAsync`
4. **Test Discovery**: The discovery API has changed significantly in v3
5. **Message Types**: v3 uses different message types (e.g., `_DiagnosticMessage`, `_TestCaseDiscovered`)

## Comparison Matrix for xUnit v3

| Approach | Pros | Cons | Complexity | v3 Compatibility |
|----------|------|------|------------|------------------|
| **Option 1: Test Collections** | Clean separation, xUnit native | More setup code | Medium | ✅ Full |
| **Option 2: BeforeAfterTestAttribute** | Simple, works with existing [Load] | Limited control, needs v3 updates | Low | ⚠️ Requires adaptation |
| **Option 3: ITestCaseOrderer** | Full control, flexible | Complex implementation for v3 | High | ⚠️ Needs v3 interfaces |
| **Option 4: Helper Method** | Simplest, no framework changes | Different API pattern | Very Low | ✅ Full |
| **Option 5: Custom Test Attribute** | Native xUnit feel, full control | More implementation work | Medium | ✅ Full |

## Recommendation for xUnit v3

**Option 4 (Helper Method Pattern)** is recommended for xUnit v3 because:
- ✅ Works with standard xUnit v3 without any framework modifications
- ✅ All tests show up in Test Explorer
- ✅ Can mix regular and load tests in the same class
- ✅ Simple and easy to understand
- ✅ No conflicts with xUnit v3's test discovery
- ✅ Uses proper `ValueTask` async patterns
- ✅ Compatible with `IAsyncLifetime`

## Migration Example for xUnit v3

**Current WebTests.cs with custom framework:**
```csharp
[Load(order: 1, concurrency: 2, duration: 5000, interval: 500)]
public async Task TestGoogleIsWorking()
{
    var response = await _httpClient!.GetAsync("https://www.google.com", TestContext.Current.CancellationToken);
    Assert.True(response.IsSuccessStatusCode);
}
```

**With Helper Method Pattern (xUnit v3):**
```csharp
[Fact]
public async Task TestGoogleIsWorking()
{
    await LoadTestRunner.RunLoadTest(
        async () =>
        {
            var response = await _httpClient!.GetAsync("https://www.google.com");
            Assert.True(response.IsSuccessStatusCode);
        },
        concurrency: 2,
        duration: 5000,
        interval: 500
    );
}
```

## Conclusion

By removing the custom test framework and using one of these alternative approaches (preferably Option 4), you can:
1. Maintain full compatibility with xUnit v3
2. Keep your load testing functionality
3. See all tests in Test Explorer
4. Mix `[Fact]`, `[Theory]`, and load tests in the same project
5. Use proper xUnit v3 async patterns with `ValueTask`
6. Leverage xUnit v3's improved performance and features