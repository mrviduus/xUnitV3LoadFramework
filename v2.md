# Framework Alternatives for xUnitV3LoadFramework

## Overview

This document explores alternative approaches to implementing load testing functionality without requiring a custom test framework, allowing standard xUnit v3 tests (`[Fact]`, `[Theory]`) to work alongside load tests.

## The Problem

The current implementation uses a custom test framework that replaces xUnit's default framework:

```csharp
[assembly: TestFramework("xUnitV3LoadFramework.Extensions.Framework.LoadTestFramework", "xUnitV3LoadFramework")]
```

This causes issues:
- Standard `[Fact]` and `[Theory]` tests don't work properly
- Only tests with `[Load]` attribute are discovered
- Conflicts with xUnit's built-in test discovery and execution

## Solution Options

### Option 1: Remove Test Framework - Use Test Collections

Remove the framework declaration completely and use xUnit's built-in test collection mechanism.

**Remove from GlobalUsings.cs:**
```csharp
// Remove this line:
// [assembly: TestFramework("xUnitV3LoadFramework.Extensions.Framework.LoadTestFramework", "xUnitV3LoadFramework")]
```

**Create a custom test collection:**
```csharp
[CollectionDefinition("Load Tests")]
public class LoadTestCollection : ICollectionFixture<LoadTestFixture>
{
}

public class LoadTestFixture : IAsyncLifetime
{
    private readonly Dictionary<string, LoadTestOrchestrator> _orchestrators = new();

    public async Task InitializeAsync()
    {
        // Initialize load testing infrastructure
    }

    public async Task DisposeAsync()
    {
        foreach (var orchestrator in _orchestrators.Values)
        {
            await orchestrator.DisposeAsync();
        }
    }

    public async Task RunLoadTest(MethodInfo method, LoadAttribute loadAttribute, object testInstance)
    {
        var key = $"{method.DeclaringType?.FullName}.{method.Name}";
        
        if (!_orchestrators.TryGetValue(key, out var orchestrator))
        {
            orchestrator = new LoadTestOrchestrator(loadAttribute);
            _orchestrators[key] = orchestrator;
        }

        await orchestrator.ExecuteLoadTest(method, testInstance);
    }
}
```

### Option 2: Use BeforeAfterTestAttribute (Simplest)

Transform the `LoadAttribute` to extend `BeforeAfterTestAttribute`:

```csharp
[AttributeUsage(AttributeTargets.Method, AllowMultiple = false)]
public class LoadAttribute : BeforeAfterTestAttribute
{
    private static readonly Dictionary<string, LoadTestOrchestrator> Orchestrators = new();
    private LoadTestOrchestrator? _orchestrator;
    
    public int Order { get; }
    public int Concurrency { get; }
    public int Duration { get; }
    public int Interval { get; }

    public LoadAttribute(int order = 1, int concurrency = 1, int duration = 1000, int interval = 100)
    {
        Order = order;
        Concurrency = concurrency;
        Duration = duration;
        Interval = interval;
    }

    public override void Before(MethodInfo methodUnderTest)
    {
        var key = $"{methodUnderTest.DeclaringType?.FullName}.{methodUnderTest.Name}";
        
        if (!Orchestrators.TryGetValue(key, out _orchestrator))
        {
            _orchestrator = new LoadTestOrchestrator(this);
            Orchestrators[key] = _orchestrator;
        }
        
        TestContext.Current = new TestContext
        {
            TestName = methodUnderTest.Name,
            StartTime = DateTime.UtcNow
        };
    }

    public override void After(MethodInfo methodUnderTest)
    {
        // Cleanup if needed
    }
}
```

### Option 3: Use ITestCaseOrderer (Most Flexible)

Create a test case orderer that handles load tests specially:

```csharp
public class LoadTestCaseOrderer : ITestCaseOrderer
{
    public IEnumerable<TTestCase> OrderTestCases<TTestCase>(IEnumerable<TTestCase> testCases) 
        where TTestCase : ITestCase
    {
        var regularTests = new List<TTestCase>();
        var loadTests = new List<(TTestCase testCase, LoadAttribute attr)>();

        foreach (var testCase in testCases)
        {
            var loadAttr = testCase.TestMethod.Method
                .GetCustomAttributes(typeof(LoadAttribute))
                .FirstOrDefault() as LoadAttribute;

            if (loadAttr != null)
            {
                loadTests.Add((testCase, loadAttr));
            }
            else
            {
                regularTests.Add(testCase);
            }
        }

        // Run regular tests first
        foreach (var test in regularTests)
            yield return test;

        // Then run load tests ordered by their Order property
        foreach (var (testCase, _) in loadTests.OrderBy(t => t.attr.Order))
            yield return testCase;
    }
}
```

**Usage:**
```csharp
[TestCaseOrderer("xUnitV3LoadFramework.Extensions.LoadTestCaseOrderer", "xUnitV3LoadFramework")]
public class MyTests
{
    [Fact]
    public void RegularTest() { }
    
    [Fact]
    [Load(concurrency: 10, duration: 5000)]
    public async Task LoadTest() { }
}
```

### Option 4: Simple Helper Method Pattern (Recommended)

The simplest approach - use regular xUnit tests and call a helper method:

```csharp
public static class LoadTestRunner
{
    public static async Task RunLoadTest(
        Func<Task> testAction,
        int concurrency = 1,
        int duration = 1000,
        int interval = 100,
        CancellationToken cancellationToken = default)
    {
        var orchestrator = new LoadTestOrchestrator(concurrency, duration, interval);
        await orchestrator.RunAsync(testAction, cancellationToken);
    }
}
```

**Usage in tests:**
```csharp
public class WebTests : IDisposable
{
    private HttpClient? _httpClient;

    public WebTests()
    {
        var setup = new TestSetup();
        setup.InitializeAsync().GetAwaiter().GetResult();
        _httpClient = setup.Host.Services.GetRequiredService<IHttpClientFactory>().CreateClient();
    }

    public void Dispose()
    {
        _httpClient?.Dispose();
    }

    [Fact]
    public async Task TestGoogleIsWorking_LoadTest()
    {
        await LoadTestRunner.RunLoadTest(
            async () =>
            {
                var response = await _httpClient!.GetAsync("https://www.google.com");
                Assert.True(response.IsSuccessStatusCode);
            },
            concurrency: 2,
            duration: 5000,
            interval: 500
        );
    }

    [Fact]
    public async Task TestGoogleIsWorking_SingleRequest()
    {
        // Regular test - runs once
        var response = await _httpClient!.GetAsync("https://www.google.com");
        Assert.True(response.IsSuccessStatusCode);
    }
}
```

## Comparison Matrix

| Approach | Pros | Cons | Complexity |
|----------|------|------|------------|
| **Option 1: Test Collections** | Clean separation, xUnit native | More setup code | Medium |
| **Option 2: BeforeAfterTestAttribute** | Simple, works with existing [Load] | Limited control over execution | Low |
| **Option 3: ITestCaseOrderer** | Full control, flexible | More complex implementation | High |
| **Option 4: Helper Method** | Simplest, no framework changes | Different API pattern | Very Low |

## Recommendation

**Option 4 (Helper Method Pattern)** is recommended because:
- ✅ Works with standard xUnit without any framework modifications
- ✅ All tests show up in Test Explorer
- ✅ Can mix regular and load tests in the same class
- ✅ Simple and easy to understand
- ✅ No conflicts with xUnit's test discovery
- ✅ Easy to migrate existing tests

## Migration Example

**Current WebTests.cs:**
```csharp
[Load(order: 1, concurrency: 2, duration: 5000, interval: 500)]
public async Task TestGoogleIsWorking()
{
    var response = await _httpClient!.GetAsync("https://www.google.com", TestContext.Current.CancellationToken);
    Assert.True(response.IsSuccessStatusCode);
}
```

**With Helper Method Pattern:**
```csharp
[Fact]
public async Task TestGoogleIsWorking()
{
    await LoadTestRunner.RunLoadTest(
        async () =>
        {
            var response = await _httpClient!.GetAsync("https://www.google.com");
            Assert.True(response.IsSuccessStatusCode);
        },
        concurrency: 2,
        duration: 5000,
        interval: 500
    );
}
```

## Conclusion

By removing the custom test framework and using one of these alternative approaches, you can:
1. Maintain full compatibility with standard xUnit v3
2. Keep your load testing functionality
3. See all tests in Test Explorer
4. Mix `[Fact]`, `[Theory]`, and load tests in the same project